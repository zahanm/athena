
# Community definitions
# ---------------------

DEFINE learners OF people USING learners_profile {
  goal
  learnables
  teachables
  students
  teachers
}

DEFINE admins OF people

# Signup process
# --------------

DEFINE state_skill_needed FOR person DO
  PERFORM "What is the skill needed to perform that task?"
  RETURN skill
END

DEFINE state_teachables FOR person DO
  PERFORM "Tell me some things you'd be interested in teaching."
  RETURN teachables
END

DEFINE identify_yourself FOR person DO
  PERFORM "Tell me your name and contact info."
  RETURN name, email
END

LISTEN TO public VIA http FOR goals

ON EACH goal DO
  learner = PERSON FROM goal
  skill = ASK learner VIA stream TO state_skill_needed
  # note teachable's'
  teachables = ASK learner VIA stream TO state_teachables


  # straightforward
  # ---------------
  learner's learners_profile.goal = goal
  ADD skill TO learner's learners_profile.learnables
  ADD teachables TO learner's learners_profile.teachables
  SAVE learner to learners

  # with a separate local variable
  # ------------------------------
  # Why like this? Well, it would be awkward to do two rounds of merging to learnables
  # and teachables
  # if we don't like line 1 and 5, then we should use 'straightforward' syntax
  profile = learner's learners_profile
  profile.goal = goal
  ADD skill TO profile.learnables
  ADD teachables TO profile.teachables
  learner's learners_profile = profile
  SAVE learner TO learners

  # alternate profile lookup syntax
  # -------------------------------
  # how about
  zahan's major FROM stanford_profile
  # naturally,
  # if there are no conflicts, can just say learner's goal
  learner's goal FROM learners_profile = goal
  ADD skill TO learner's learnables FROM learners_profile
  ADD teachables TO learner's teachables FROM learners_profile
  SAVE learner TO learners


  identity = ASK learner VIA stream TO identify_yourself
  learner's name = identity.name
  learner's email = identity.email
  SAVE learner TO public
END

# admin panel
# -----------
#
# Human moderated pairings
#

# Using a LISTEN, since we want up to date information about the pairs
# when making the request, so the data needs to be fetched at request time

# list_unpaired_request is undefined earlier, will use '@value' on client
LISTEN TO admins VIA http FOR list_unpaired_requests

ON EACH list_unpaired_request DO
  unpaired = PEOPLE FROM athena WHERE learner == NULL OR teacher == NULL
  RETURN unpaired
END

# Listen for pairings made by the admins
DEFINE pairing { learner, teacher }

LISTEN TO admins VIA http FOR pairings

ON EACH pairing DO
  # assuming that learner and teacher are correctly populated
  learner = pairing.learner
  teacher = pairing.teacher
  ADD teacher TO learner's learners_profile.teachers
  ADD learner TO teacher's learners_profile.students
END

# external ranking
# ----------------
#
# Automated pairing, driven by external Python functions
#

# This function is just to choose the best teacher
# TODO assuming that we're optimizing for the best teachers and
#   not learners
DEFINE best_unpaired_teacher ON learner DO
  # TODO intersection syntax?
  potential_teachers = PEOPLE FROM athena WHERE learner == NULL AND (teachables & learner.learnables) > 0
  best_teachers = COMPUTE rank_k_teachers ON learner, potential_teachers
  # TODO slice syntax?
  RETURN best_teachers[0]
END

DEFINE rank_k_teachers FOR shell ON me, teachers USING k = 5 DO
  PERFORM "python ranking.py"
  RETURN teachers_list
END
